# Features covered: dom command
#
# This file contains a collection of tests for the dom command  of
# tDOM.
#
#    domCmd-1.*:  createDocument, createDocumentNS
#    domCmd-2.*:  parse
#    domCmd-3.*:  isName, isNCName, isCharData
#    domCmd-4.*:  asXML, asHTML
#    domCmd-5.*:  publicId, systemId
#    domCmd-6.*:  parse -useForeignDTD
#    domCmd-7.*:  external entities
#    domCmd-8.*:  toXSLTcmd
#    domCmd-9.*:  asText
#    domCmd-10.*: normalize
#
# Copyright (c) 2002 Rolf Ade.

source [file join [file dir [info script]] loadtdom.tcl]

test domCmd-1.1 {createDocument with root node name not a XML Name} {
    list [catch {dom createDocument "root node"} msg] $msg
} "1 {invalid root element name}"

test domCmd-1.2 {createDocument with root node name not a XML Name} {
    list [catch {dom createDocument "1root"} msg] $msg
} "1 {invalid root element name}"

test domCmd-1.3 {createDocument - root name us-ascii} {
    dom createDocument "root" doc 
    set root [$doc documentElement]
    set result [$root nodeName]
    $doc delete
    set result
} "root"

test domCmd-1.4 {createDocument - root name with UTF-8 chars} {
    dom createDocument "\u00c4\u00d4\u00dc" doc 
    set root [$doc documentElement]
    set result [$root nodeName]
    $doc delete
    set result
} "\u00c4\u00d4\u00dc"
    
test domCmd-1.5 {createDocument with FQ root name} {
    dom createDocument "foo:bar" doc
    set root [$doc documentElement]
    set result [$root nodeName]
    $doc delete
    set result
} "foo:bar"

test domCmd-1.6 {createDocument with wrong # of args} {
    list [catch {dom createDocument "root" "http:/foo:bar" doc} msg] $msg
} "1 {wrong \# args: should be \"createDocument docElemName ?newObjVar?\"}"

test domCmd-1.7 {createDocumentNS - check root name} {
    set doc [dom createDocumentNS "http://foo.bar" "root"]
    set root [$doc documentElement]
    set result [$root nodeName]
    $doc delete
    set result
} "root"

test domCmd-1.8 {createDocumentNS - check the NS of the created root} {
    dom createDocumentNS "http://foo.bar" "root" doc
    set root [$doc documentElement]
    set result [$root namespaceURI]
    $doc delete
    set result
} "http://foo.bar"    

test domCmd-1.9 {createDocumentNS with root name not a NCName} {
    list [catch {dom createDocumentNS "http://foo.bar" "foo bar" doc} msg] $msg
} "1 {invalid local name}"

test domCmd-1.10 {createDocumentNS with root name not a NCName} {
    list [catch {dom createDocumentNS "http://foo.bar" "a:b:c" doc} msg] $msg
} "1 {invalid local name}"

test domCmd-1.11 {createDocumentNS with root name not a NCName} {
    list [catch {dom createDocumentNS "http://foo.bar" "a b:b" doc} msg] $msg
} "1 {invalid prefix name}"

test domCmd-1.12 {createDocumentNS with root name not a NCName} {
    list [catch {dom createDocumentNS "http://foo.bar" "a:a b" doc} msg] $msg
} "1 {invalid local name}"

test domCmd-1.13 {createDocumentNS - check root name} {
    set doc [dom createDocumentNS "http://foo.bar" foo:root]
    set root [$doc documentElement]
    set result [$root nodeName]
    $doc delete
    set result
} "foo:root"

test domCmd-1.14 {createDocument - rename the doc cmd} {
    set doc [dom createDocument root]
    if {[info commands fooCmd] == "fooCmd"} {
        rename fooCmd {}
    }
    rename $doc fooCmd
    set result [[fooCmd documentElement] nodeName]
    fooCmd delete
    set result
} {root}

test domCmd-2.1 {Don't quash white space at start or end of non white space content} {
    set doc [dom parse {<root>
    some content
    </root>}]
    set root [$doc documentElement]
    $root text
} {
    some content
    }

test domCmd-2.2 {parse doc with various re-declaration of a prefix} {
    set doc [dom parse {<p:a xmlns:p="uri1">
    <p:b xmlns:p="uri2">
        <p:c xmlns:p="uri1"/>
    </p:b>
</p:a>}]
    set root [$doc documentElement]
    set result [$root asXML]
    $doc delete
    set result
} {<p:a xmlns:p="uri1">
    <p:b xmlns:p="uri2">
        <p:c xmlns:p="uri1"/>
    </p:b>
</p:a>
}

test domCmd-2.3 {parse doc with default NS declaration} {
    set doc [dom parse {<a xmlns:p="uri">
    <p:b/>
    <p:b/>
</a>}]
    set root [$doc documentElement]
    set result [$root asXML]
    $doc delete
    set result
} {<a xmlns:p="uri">
    <p:b/>
    <p:b/>
</a>
}

test domCmd-2.4 {parse method: syntax check} {
    set doc [dom parse -keepEmpties {<root>
  text
    </root>}]
    set result [$doc asXML -indent none]
    $doc delete
    set result
} {<root>
  text
    </root>}

test domCmd-2.5 {parse method: syntax check} {
    set doc [dom parse -useForeignDTD 0 -keepEmpties {<root>
  text
    </root>}]
    set result [$doc asXML -indent none]
    $doc delete
    set result
} {<root>
  text
    </root>}

test domCmd-2.6 {parse method: syntax check} {
    set xmlFile [makeFile {<root>    </root>} domCmd.xml]
    set fd [open $xmlFile]
    set doc [dom parse -channel $fd -keepEmpties]
    close $fd
    set root [$doc documentElement]
    set result [$root asXML -indent none]
    $doc delete
    set result
} {<root>    </root>}

test domCmd-2.7 {parse method: syntax check} {
    catch {unset -keepEmpties}
    set xmlFile [makeFile {<root>    </root>} domCmd.xml]
    set fd [open $xmlFile]
    set doc [dom parse -channel $fd -keepEmpties]
    close $fd
    $doc delete
    info exists -keepEmpties
} {0}

test domCmd-2.8 {parse method: bogus option} {
    set result [catch {set doc [dom parse -bogusOption foo <root/>]} errMsg]
    lappend result $errMsg
} {1 {bad option "-bogusOption": must be -keepEmpties, -simple, -html, -feedbackAfter, -channel, -baseurl, -externalentitycommand, -useForeignDTD, or -paramentityparsing}}

test domCmd-2.9 {parse method: bogus option} {
    catch {unset -keepEmpties}
    set xmlFile [makeFile {<root>    </root>} domCmd.xml]
    set fd [open $xmlFile]
    set result [catch {set doc [dom parse -channel $fd -bogusOption]} errMsg]
    close $fd
    lappend result $errMsg
} {1 {bad option "-bogusOption": must be -keepEmpties, -simple, -html, -feedbackAfter, -channel, -baseurl, -externalentitycommand, -useForeignDTD, or -paramentityparsing}}

set domCmd_dtd "
    <!ELEMENT root EMPTY>
    <!ATTLIST root lang CDATA #FIXED \"en\">"

proc extRefResolver {base systemId publicId} {
    global domCmd_dtd

    if {$publicId == "DOMCMDTEST"} {
        return [list string $base $domCmd_dtd]
    } else {
        return [::tDOM::extRefHandler $base $systemId $publicId]
    }
}

test domCmd-2.10 {parse method: -paramentityparsing default is 'always'} {
    set doc [dom parse -externalentitycommand extRefResolver {
        <!DOCTYPE root PUBLIC "DOMCMDTEST" "dummysystemID">
        <root/>
    }]
    set root [$doc documentElement]
    set result [$root @lang]
    $doc delete
    set result
} {en}

test domCmd-2.11 {parse method: explicit -paramentityparsing always} {
    set doc [dom parse -externalentitycommand extRefResolver \
                       -paramentityparsing always {
        <!DOCTYPE root PUBLIC "DOMCMDTEST" "dummysystemID">
        <root/>
    }]
    set root [$doc documentElement]
    set result [$root @lang]
    $doc delete
    set result
} {en}

test domCmd-2.12 {parse method: -paramentityparsing never} {
    set doc [dom parse -externalentitycommand extRefResolver \
                       -paramentityparsing never {
        <!DOCTYPE root PUBLIC "DOMCMDTEST" "dummysystemID">
        <root/>
    }]
    set root [$doc documentElement]
    set result [catch {set result [$root @lang]} errMsg]
    $doc delete
    lappend result $errMsg
    set result
} {1 {Attribute "lang" not found!}}

test domCmd-2.13 {parse method: -paramentityparsing notstandalone} {
    set doc [dom parse -externalentitycommand extRefResolver \
                       -paramentityparsing notstandalone {
        <!DOCTYPE root PUBLIC "DOMCMDTEST" "dummysystemID">
        <root/>
    }]
    set root [$doc documentElement]
    set result [$root @lang]
    $doc delete
    set result
} {en}

test domCmd-2.14 {parse method: -paramentityparsing notstandalone} {
    set doc [dom parse -externalentitycommand extRefResolver \
                       -paramentityparsing notstandalone \
                       {<?xml version="1.0" standalone="yes"?>
        <!DOCTYPE root PUBLIC "DOMCMDTEST" "dummysystemID">
        <root/>
    }]
    set root [$doc documentElement]
    set result [catch {set result [$root @lang]} errMsg]
    $doc delete
    lappend result $errMsg
    set result
} {1 {Attribute "lang" not found!}}

test domCmd-2.15 {parse method: -paramentityparsing notstandalone} {
    set doc [dom parse -externalentitycommand extRefResolver \
                       -paramentityparsing notstandalone \
                       {<?xml version="1.0" standalone="no"?>
        <!DOCTYPE root PUBLIC "DOMCMDTEST" "dummysystemID">
        <root/>
    }]
    set root [$doc documentElement]
    set result [$root @lang]
    $doc delete
    set result
} {en}

test domCmd-2.16 {parse method: wrong value arg for -paramentityparsing} {
    set result [catch {set doc [dom parse -paramentityparsing wrong {
        <root/>}]} errMsg]
    lappend result $errMsg
} {1 {bad value "wrong": must be always, never, or notstandalone}}

# The following is syntactically wrong. It's used, to test the
# error reporting in external DTDs
set domCmd_dtd "<!ATTLIST root lang #FIXED \"en\">"

test domCmd-2.17 {parse method: test reporting of error in external subset} {
    set result [catch {set doc [dom parse \
            -externalentitycommand extRefResolver {
        <!DOCTYPE root PUBLIC "DOMCMDTEST" "dummysystemID">
        <root/>
    }]} errMsg]
    lappend result $errMsg
} {1 {error "syntax error" in entity "dummysystemID" at line 1 character 20
"<!ATTLIST root lang # <--Error-- FIXED "en">"}}

test domCmd-2.18 {parse document with nodes before and after the documentElement} {
    set doc [dom parse {<!-- First comment -->
<doc>
  <!-- Front comment -->
  <inner/>
  <!-- Back comment -->
</doc>
<!-- Last comment -->}]
    set result [$doc asXML -indent none]
    $doc delete
    set result
} {<!-- First comment --><doc><!-- Front comment --><inner/><!-- Back comment --></doc><!-- Last comment -->}

test domCmd-2.19 {parse document - rename docCmd} {
    set doc [dom parse {<root>foo<child/></root>}]
    if {[info commands fooCmd] == "fooCmd"} {
        rename fooCmd {}
    }
    rename $doc fooCmd
    set result [fooCmd asXML -indent none]
    fooCmd delete
    set result
} {<root>foo<child/></root>}

test domCmd-2.20 {parse - doc with internal subset parsed with -keepEmpties} {
    set doc [dom parse -keepEmpties {
        <!DOCTYPE root [
           <!ELEMENT root EMPTY>
           <!-- Comment inside the DTD -->
           <?aPI Inside the DTD?>
           <!ATTLIST root lang CDATA #FIXED "en">
          ]>
        <root/>}]
    $doc documentElement root
    set result ""
    foreach node [$root selectNodes /node()] {
        switch [$node nodeType] {
            TEXT_NODE {
                lappend result TEXT_NODE
                lappend result [string length [$node value]]
            }
            COMMENT_NODE {
                lappend result COMMENT_NODE
                lappend result [string length [$node value]]
            }
            PROCESSING_INSTRUCTION_NODE {
                lappend result PROCESSING_INSTRUCTION_NODE
                lappend result [$node target]
                lappend result [$node data]
            }
            ELEMENT_NODE {
                lappend result ELEMENT_NODE
                lappend result [$node nodeName]
            }
            default {
                lappend result [$node nodeType]
            }
        }
    }
    $doc delete
    set result
} {ELEMENT_NODE root}

test domCmd-3.1 {isName} {
    dom isName ":foo"
} {1}

test domCmd-3.2 {isName} {
    dom isName "_foo"
} {1}

test domCmd-3.3 {isName} {
    dom isName "foo:bar:baz"
} {1}

test domCmd-3.4 {isName} {
    dom isName "-foo"
} {0}

test domCmd-3.5 {isName} {
    dom isName ".foo"
} {0}

test domCmd-3.6 {isName} {
    catch {dom isName}
} {1}

test domCmd-3.7 {isName} {
    catch {dom isName foo bar}
} {1}

# The following character classes are out of XML 1.0 Second Edition rec,
# Appendix B (which is following the Unicode standard).

set BaseChar {
    {0x0041 0x005A} {0x0061 0x007A} {0x00C0 0x00D6}
    {0x00D8 0x00F6} {0x00F8 0x00FF} {0x0100 0x0131} {0x0134 0x013E}
    {0x0141 0x0148} {0x014A 0x017E} {0x0180 0x01C3}
    {0x01CD 0x01F0} {0x01F4 0x01F5} {0x01FA 0x0217} {0x0250 0x02A8}
    {0x02BB 0x02C1} 0x0386 {0x0388 0x038A} 0x038C
    {0x038E 0x03A1} {0x03A3 0x03CE} {0x03D0 0x03D6} 0x03DA 0x03DC
    0x03DE 0x03E0 {0x03E2 0x03F3} {0x0401 0x040C}
    {0x040E 0x044F} {0x0451 0x045C} {0x045E 0x0481} {0x0490 0x04C4}
    {0x04C7 0x04C8} {0x04CB 0x04CC} {0x04D0 0x04EB}
    {0x04EE 0x04F5} {0x04F8 0x04F9} {0x0531 0x0556} 0x0559
    {0x0561 0x0586} {0x05D0 0x05EA} {0x05F0 0x05F2} {0x0621 0x063A}
    {0x0641 0x064A} {0x0671 0x06B7} {0x06BA 0x06BE}
    {0x06C0 0x06CE} {0x06D0 0x06D3} 0x06D5 {0x06E5 0x06E6}
    {0x0905 0x0939} 0x093D {0x0958 0x0961} {0x0985 0x098C}
    {0x098F 0x0990} {0x0993 0x09A8} {0x09AA 0x09B0} 0x09B2
    {0x09B6 0x09B9} {0x09DC 0x09DD} {0x09DF 0x09E1} {0x09F0 0x09F1}
    {0x0A05 0x0A0A} {0x0A0F 0x0A10} {0x0A13 0x0A28}
    {0x0A2A 0x0A30} {0x0A32 0x0A33} {0x0A35 0x0A36} {0x0A38 0x0A39}
    {0x0A59 0x0A5C} 0x0A5E {0x0A72 0x0A74} {0x0A85 0x0A8B}
    0x0A8D {0x0A8F 0x0A91} {0x0A93 0x0AA8} {0x0AAA 0x0AB0}
    {0x0AB2 0x0AB3} {0x0AB5 0x0AB9} 0x0ABD 0x0AE0 {0x0B05 0x0B0C}
    {0x0B0F 0x0B10} {0x0B13 0x0B28} {0x0B2A 0x0B30}
    {0x0B32 0x0B33} {0x0B36 0x0B39} 0x0B3D {0x0B5C 0x0B5D}
    {0x0B5F 0x0B61} {0x0B85 0x0B8A} {0x0B8E 0x0B90} {0x0B92 0x0B95}
    {0x0B99 0x0B9A} 0x0B9C {0x0B9E 0x0B9F} {0x0BA3 0x0BA4}
    {0x0BA8 0x0BAA} {0x0BAE 0x0BB5} {0x0BB7 0x0BB9} {0x0C05 0x0C0C}
    {0x0C0E 0x0C10} {0x0C12 0x0C28} {0x0C2A 0x0C33}
    {0x0C35 0x0C39} {0x0C60 0x0C61} {0x0C85 0x0C8C} {0x0C8E 0x0C90}
    {0x0C92 0x0CA8} {0x0CAA 0x0CB3} {0x0CB5 0x0CB9} 0x0CDE
    {0x0CE0 0x0CE1} {0x0D05 0x0D0C} {0x0D0E 0x0D10} {0x0D12 0x0D28}
    {0x0D2A 0x0D39} {0x0D60 0x0D61} {0x0E01 0x0E2E} 0x0E30
    {0x0E32 0x0E33} {0x0E40 0x0E45} {0x0E81 0x0E82} 0x0E84
    {0x0E87 0x0E88} 0x0E8A 0x0E8D {0x0E94 0x0E97} {0x0E99 0x0E9F}
    {0x0EA1 0x0EA3} 0x0EA5 0x0EA7 {0x0EAA 0x0EAB}
    {0x0EAD 0x0EAE} 0x0EB0 {0x0EB2 0x0EB3} 0x0EBD {0x0EC0 0x0EC4}
    {0x0F40 0x0F47} {0x0F49 0x0F69} {0x10A0 0x10C5}
    {0x10D0 0x10F6} 0x1100 {0x1102 0x1103} {0x1105 0x1107} 0x1109
    {0x110B 0x110C} {0x110E 0x1112} 0x113C 0x113E 0x1140
    0x114C 0x114E 0x1150 {0x1154 0x1155} 0x1159 {0x115F 0x1161}
    0x1163 0x1165 0x1167 0x1169 {0x116D 0x116E}
    {0x1172 0x1173} 0x1175 0x119E 0x11A8 0x11AB {0x11AE 0x11AF}
    {0x11B7 0x11B8} 0x11BA {0x11BC 0x11C2} 0x11EB 0x11F0
    0x11F9 {0x1E00 0x1E9B} {0x1EA0 0x1EF9} {0x1F00 0x1F15}
    {0x1F18 0x1F1D} {0x1F20 0x1F45} {0x1F48 0x1F4D} {0x1F50 0x1F57}
    0x1F59 0x1F5B 0x1F5D {0x1F5F 0x1F7D} {0x1F80 0x1FB4}
    {0x1FB6 0x1FBC} 0x1FBE {0x1FC2 0x1FC4} {0x1FC6 0x1FCC}
    {0x1FD0 0x1FD3} {0x1FD6 0x1FDB} {0x1FE0 0x1FEC} {0x1FF2 0x1FF4}
    {0x1FF6 0x1FFC} 0x2126 {0x212A 0x212B} 0x212E
    {0x2180 0x2182} {0x3041 0x3094} {0x30A1 0x30FA} {0x3105 0x312C}
    {0xAC00 0xD7A3}
}

set Ideographic {
    {0x4E00 0x9FA5} 0x3007 {0x3021 0x3029}
}

set CombiningChar {
    {0x0300 0x0345} {0x0360 0x0361} {0x0483 0x0486} {0x0591 0x05A1}
    {0x05A3 0x05B9} {0x05BB 0x05BD} 0x05BF {0x05C1 0x05C2}
    0x05C4 {0x064B 0x0652} 0x0670 {0x06D6 0x06DC} {0x06DD 0x06DF}
    {0x06E0 0x06E4} {0x06E7 0x06E8} {0x06EA 0x06ED}
    {0x0901 0x0903} 0x093C {0x093E 0x094C} 0x094D {0x0951 0x0954}
    {0x0962 0x0963} {0x0981 0x0983} 0x09BC 0x09BE 0x09BF
    {0x09C0 0x09C4} {0x09C7 0x09C8} {0x09CB 0x09CD} 0x09D7
    {0x09E2 0x09E3} 0x0A02 0x0A3C 0x0A3E 0x0A3F {0x0A40 0x0A42}
    {0x0A47 0x0A48} {0x0A4B 0x0A4D} {0x0A70 0x0A71}
    {0x0A81 0x0A83} 0x0ABC {0x0ABE 0x0AC5} {0x0AC7 0x0AC9}
    {0x0ACB 0x0ACD} {0x0B01 0x0B03} 0x0B3C {0x0B3E 0x0B43}
    {0x0B47 0x0B48} {0x0B4B 0x0B4D} {0x0B56 0x0B57} {0x0B82 0x0B83}
    {0x0BBE 0x0BC2} {0x0BC6 0x0BC8} {0x0BCA 0x0BCD} 0x0BD7
    {0x0C01 0x0C03} {0x0C3E 0x0C44} {0x0C46 0x0C48} {0x0C4A 0x0C4D}
    {0x0C55 0x0C56} {0x0C82 0x0C83} {0x0CBE 0x0CC4}
    {0x0CC6 0x0CC8} {0x0CCA 0x0CCD} {0x0CD5 0x0CD6} {0x0D02 0x0D03}
    {0x0D3E 0x0D43} {0x0D46 0x0D48} {0x0D4A 0x0D4D} 0x0D57
    0x0E31 {0x0E34 0x0E3A} {0x0E47 0x0E4E} 0x0EB1 {0x0EB4 0x0EB9}
    {0x0EBB 0x0EBC} {0x0EC8 0x0ECD} {0x0F18 0x0F19} 0x0F35
    0x0F37 0x0F39 0x0F3E 0x0F3F {0x0F71 0x0F84} {0x0F86 0x0F8B}
    {0x0F90 0x0F95} 0x0F97 {0x0F99 0x0FAD} {0x0FB1 0x0FB7}
    0x0FB9 {0x20D0 0x20DC} 0x20E1 {0x302A 0x302F} 0x3099 0x309A
}

set Digit {
    {0x0030 0x0039} {0x0660 0x0669} {0x06F0 0x06F9} {0x0966 0x096F}
    {0x09E6 0x09EF} {0x0A66 0x0A6F} {0x0AE6 0x0AEF}
    {0x0B66 0x0B6F} {0x0BE7 0x0BEF} {0x0C66 0x0C6F} {0x0CE6 0x0CEF}
    {0x0D66 0x0D6F} {0x0E50 0x0E59} {0x0ED0 0x0ED9}
    {0x0F20 0x0F29}
}

set Extender {
    0x00B7 0x02D0 0x02D1 0x0387 0x0640 0x0E46 0x0EC6 0x3005
    {0x3031 0x3035} {0x309D 0x309E} {0x30FC 0x30FE}
}

proc sortCmd {a b} {
    if {[lindex $a 0] > [lindex $b 0]} {
        return 1
    } else {
        return -1
    }
}

#  if {$tcl_version < 8.4} {
#      set nameStartChars [lsort -command sortCmd \
#              [concat $BaseChar $Ideographic 0x005F 0x003A]]
#  } else {
#      set nameStartChars [lsort -integer -index 0 \
#              [concat $BaseChar $Ideographic 0x005F 0x003A]]
#  }

set nameStartChars [lsort -command sortCmd \
        [concat $BaseChar $Ideographic 0x005F 0x003A]]

# Append stop char needed by the test code to work properly.
lappend nameStartChars 0x10000

test domCmd-3.8 {isName} {longRunning && need_i18n} {
    set ind 0
    set nr 0
    while {$nr < 65536} {
        set range [lindex $nameStartChars $ind]
        incr ind
        if {[llength $range] == 2} {
            foreach {min max} $range break
        } else {
            set min $range
            set max $range
        }
        while {$nr < $min} {
            if {[dom isName [subst \\u[format "%04x" $nr]]] != 0} {
                error "wrong 'isName' result for name start char #x[format "%04x" $nr] - should be illegal"
            }
            incr nr
        }
        if {$nr == 0x10000} {break}
        while {$nr <= $max} {
            if {[dom isName [subst \\u[format "%04x" $nr]]] != 1} {
                error "wrong 'isName' result for name start char #x[format "%04x" $nr] - should be legal"
            }
            incr nr
        }
    }
    set nr
} {65536}

set nameChars [lsort -command sortCmd \
        [concat $BaseChar $Ideographic $Digit 0x002E 0x002D 0x005F 0x003A \
                $CombiningChar $Extender]]

# Append stop char needed by the test code to work properly.
lappend nameChars 0x10000

test domCmd-3.9 {isName} {longRunning && need_i18n} {
    set ind 0
    set nr 0
    while {$nr < 65536} {
        set range [lindex $nameChars $ind]
        incr ind
        if {[llength $range] == 2} {
            foreach {min max} $range break
        } else {
            set min $range
            set max $range
        }
        while {$nr < $min} {
            if {[dom isName a[subst \\u[format "%04x" $nr]]] != 0} {
                error "wrong 'isName' result for name char #x[format "%04x" $nr] - should be illegal"
            }
            incr nr
        }
        if {$nr == 0x10000} {break}
        while {$nr <= $max} {
            if {[dom isName a[subst \\u[format "%04x" $nr]]] != 1} {
                error "wrong 'isName' result for name char #x[format "%04x" $nr] - should be legal"
            }
            incr nr
        }
    }
    set nr
} {65536}


test domCmd-3.10 {isNCName} {
    dom isNCName ":foo"
} {0}

test domCmd-3.11 {isNCName} {
    dom isNCName "_foo"
} {1}

test domCmd-3.12 {isNCName} {
    dom isNCName "foo:bar:baz"
} {0}

test domCmd-3.13 {isNCName} {
    dom isNCName "-foo"
} {0}

test domCmd-3.14 {isNCName} {
    dom isNCName ".foo"
} {0}

test domCmd-3.15 {isNCName} {
    catch {dom isNCName}
} {1}

test domCmd-3.16 {isNCName} {
    catch {dom isNCName foo bar}
} {1}


test domCmd-3.17 {isQName} {
    dom isQName ":foo"
} {0}

test domCmd-3.18 {isQName} {
    dom isQName "_foo"
} {1}

test domCmd-3.19 {isQName} {
    dom isQName "foo:bar:baz"
} {0}

test domCmd-3.20 {isQName} {
    dom isQName "-foo"
} {0}

test domCmd-3.21 {isQName} {
    dom isQName ".foo"
} {0}

test domCmd-3.22 {isQName} {
    dom isQName "foo:bar"
} {1}

test domCmd-3.23 {isQName} {
    catch {dom isQName}
} {1}

test domCmd-3.24 {isQName} {
    catch {dom isQName foo bar}
} {1}

test domCmd-3.25 {isQName} {
    dom isQName "foo bar"
} {0}
    
test domCmd-3.26 {isQName} {
    dom isQName "woozbiz:"
} {0}

set XMLChars {
    0x9 0xA 0xD {0x20 0xD7FF} {0xE000 0xFFFD} {0x10000 0x10FFFF}
}

test domCmd-3.27 {isCharData} {longRunning && need_i18n} {
    set ind 0
    set nr 1
    while {$nr < 65536} {
        set range [lindex $XMLChars $ind]
        incr ind
        if {[llength $range] == 2} {
            foreach {min max} $range break
        } else {
            set min $range
            set max $range
        }
        while {$nr < $min} {
            if {[dom isCharData "a[subst \\u[format "%04x" $nr]]b"] != 0} {
                error "wrong 'isCharData' result for char #x[format "%04x" $nr] - should be illegal"
            }
            incr nr
        }
        if {$nr == 0x10000} {break}
        while {$nr <= $max} {
            if {[dom isCharData "a[subst \\u[format "%04x" $nr]]b"] != 1} {
                error "wrong 'isCharData' result for char #x[format "%04x" $nr] - should be legal"
            }
            incr nr
        }
    }
    set nr
} {65536}

test domCmd-4.1 {asXML -escapeNonASCII} {need_i18n} {
    set doc [dom parse [tDOM::xmlReadFile \
            [file join [file dir [info script]] data/i18n_1.xml]]]
    set result [$doc asXML -escapeNonASCII]
    $doc delete
    set result
} {<test>&#1072;&#1073;&#1074;&#1075;&#1076;&#1077;&#1078;&#1079;&#1080;&#1081;</test>
}

test domCmd-4.2 {asXML -escapeNonASCII; comments and PI's are not altered} {need_i18n} {
    set doc [dom parse [tDOM::xmlReadFile \
            [file join [file dir [info script]] data/i18n_2.xml]]]
    set result [$doc asXML -indent none -escapeNonASCII]
    $doc delete
    set result
} {<root withUmlauts="&#228;&#246;&#252;&#223;"><!-- A comment with german umlauts: äöüß --><?äöüß A processing node with german umlauts?>
german umlauts: &#228;&#246;&#252;&#223;
</root>}

test domCmd-4.3 {asHTML -escapeNonASCII -htmlEntities} {need_i18n} {
    set doc [dom parse {<html><body>&#228;&#xfc;&#8222;&#8223;&#8224;</body></html>}]
    set result [$doc asHTML -escapeNonASCII -htmlEntities]
    $doc delete
    set result
} {<html><body>&auml;&uuml;&bdquo;&#8223;&dagger;</body></html>}


set doc [dom parse <root/>]

test domCmd-4.4 {asXML -doctypeDeclaration} {
    $doc asXML -doctypeDeclaration 1
} {<!DOCTYPE root>
<root/>
}

test domCmd-4.5 {asXML -doctypeDeclaration without boolean value (error)} {
    set errMsg ""
    catch {$doc asXML -doctypeDeclaration} errMsg
    set errMsg
} {-doctypeDeclaration must have a boolean value as argument}

test domCmd-4.6 {asXML -doctypeDeclaration 0} {
    $doc asXML -doctypeDeclaration 0
} {<root/>
}

$doc delete

test domCmd-4.7 {asXML -doctypeDeclaration} {
    set doc [dom parse {<!DOCTYPE root PUBLIC "-//foo//DTD bar x.y//EN" 
                                       "file:///boo.baz"><root/>}]
    set result [$doc asXML -doctypeDeclaration 1]
    $doc delete
    set result
} {<!DOCTYPE root PUBLIC "-//foo//DTD bar x.y//EN" "file:///boo.baz">
<root/>
}

test domCmd-4.8 {asXML -doctypeDeclaration} {
    set doc [dom parse {<!DOCTYPE root SYSTEM "file:///boo.baz"><root/>}]
    set result [$doc asXML -doctypeDeclaration 1]
    $doc delete
    set result
} {<!DOCTYPE root SYSTEM "file:///boo.baz">
<root/>
}   

test domCmd-4.9 {asXML -doctypeDeclaration} {
    set doc [dom parse {<!DOCTYPE root SYSTEM "file:///boo.baz"><root/>}]
    set result [$doc asXML -doctypeDeclaration true]
    $doc delete
    set result
} {<!DOCTYPE root SYSTEM "file:///boo.baz">
<root/>
}   

test domCmd-4.10 {asXML - unknown option} {
    set doc [dom parse {<!DOCTYPE root SYSTEM "file:///boo.baz"><root/>}]
    set errMsg ""
    catch {$doc asXML -fooOption 1} errMsg
    $doc delete
    set errMsg
} {bad option "-fooOption": must be -indent, -channel, -escapeNonASCII, or -doctypeDeclaration}

test domCmd-4.11 {asXML - non boolean value to -doctypeDeclaration} {
    set doc [dom parse {<!DOCTYPE root SYSTEM "file:///boo.baz"><root/>}]
    set errMsg ""
    catch {$doc asXML -doctypeDeclaration foo} errMsg
    $doc delete
    set errMsg
} {expected boolean value but got "foo"}

test domCmd-4.12 {asXML - shortened option} {
    set doc [dom parse {<!DOCTYPE root SYSTEM "file:///boo.baz"><root/>}]
    set result [$doc asXML -doctype 1]
    $doc delete
    set result
} {<!DOCTYPE root SYSTEM "file:///boo.baz">
<root/>
}   

test domCmd-4.13 {asHTML -doctypeDeclaration} {
    set doc [dom createDocument HTML]
    set result [$doc asHTML -doctypeDeclaration 1]
    $doc delete
    set result
} {<!DOCTYPE HTML>
<html></html>}

test domCmd-4.14 {asHTML -doctypeDeclaration} {
    set doc [dom parse {<!DOCTYPE HTML 
    PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
    <html><body><p>boo</p></body></html>}]
    set result [$doc asHTML -doctypeDeclaration 1]
    $doc delete
    set result
} {<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body><p>boo</p></body></html>}

set doc [dom parse <root/>]

test domCmd-5.1 {publicId - no publicId there} {
    $doc publicId
} {}

test domCmd-5.2 {systemId - no systemId there} {
    $doc systemId
} {}

$doc delete
set doc [dom parse {<!DOCTYPE root PUBLIC "-//foo//DTD bar x.y//EN" "file:///boo.baz"><root/>}]

test domCmd-5.3 {publicId from parsed document} {
    $doc publicId
} {-//foo//DTD bar x.y//EN}

test domCmd-5.4 {systemId from parsed document} {
    $doc systemId
} {file:///boo.baz}

$doc delete
set doc [dom parse {<!DOCTYPE root SYSTEM "file:///boo.baz"><root/>}]

test domCmd-5.5 {publicId but document has only SYSTEM} {
    $doc publicId
} {}

test domCmd-5.6 {systemId, document has only SYSTEM} {
    $doc systemId
} {file:///boo.baz}

test domCmd-5.7 {publicId - set public identifier} {
    set result [$doc publicId "file:///woo.hoo"]
    append result " [$doc publicId]"
} { file:///woo.hoo} 

test domCmd-5.8 {publicId - set public identifier} {
    $doc publicId "http://www.tdom.org"
    $doc asXML -indent no -doctypeDeclaration 1
} {<!DOCTYPE root PUBLIC "http://www.tdom.org" "file:///boo.baz">
<root/>}

test domCmd-5.9 {systemId - set system identifier} {
    set result [$doc systemId "file:///woo.hoo"]
    append result " [$doc systemId]"
} {file:///boo.baz file:///woo.hoo}

test domCmd-5.10 {systemId - set system identifier} {
    $doc systemId "file:///whooze.moo"
    $doc asXML -indent no -doctypeDeclaration 1
} {<!DOCTYPE root PUBLIC "http://www.tdom.org" "file:///whooze.moo">
<root/>}

test domCmd-5.11 {publicId - set to empty string} {
    $doc publicId ""
    $doc asXML -indent no -doctypeDeclaration 1
} {<!DOCTYPE root SYSTEM "file:///whooze.moo">
<root/>}

test domCmd-5.12 {systemId - set to empty string} {
    $doc systemId ""
    $doc asXML -indent no -doctypeDeclaration 1
} {<!DOCTYPE root>
<root/>}

$doc delete

test domCmd-6.1 {-useForeignDTD 0} {
    set doc [dom parse -useForeignDTD 0 {<root/>}]
    $doc delete
} {}

test domCmd-6.2 {-useForeignDTD 1 with document with internal subset} {need_uri} {
    set baseURI file://[file join [pwd] [file dir [info script]] domCmd.test]
    set ::tDOM::useForeignDTD "data/domCmd1.dtd"
    set doc [dom parse \
            -useForeignDTD 1 \
            -baseurl $baseURI \
            -externalentitycommand ::tDOM::extRefHandler {
<!DOCTYPE root [
    <!ATTLIST root fixed CDATA #FIXED "toThat">
]>
<root/>}]
    set root [$doc documentElement]
    set result [$root @fixed]
    $doc delete
    set result
} {toThat}

test domCmd-6.3 {-useForeignDTD 1 with document with internal subset} {need_uri} {
    set baseURI file://[file join [pwd] [file dir [info script]] domCmd.test]
    set ::tDOM::useForeignDTD "data/domCmd1.dtd"
    set doc [dom parse \
            -useForeignDTD 1 \
            -baseurl $baseURI \
            -externalentitycommand ::tDOM::extRefHandler {
<!DOCTYPE root [
    <!ATTLIST root fixed2 CDATA #FIXED "toThat">
]>
<root/>}]
    set root [$doc documentElement]
    set result [$root @fixed]
    lappend result [$root @fixed2]
    $doc delete
    set result
} {toThis toThat}

test domCmd-6.4 {-useForeignDTD 1 with document without document declaration} {need_uri} {
    set baseURI file://[file join [pwd] [file dir [info script]] domCmd.test]
    set ::tDOM::useForeignDTD "data/domCmd1.dtd"
    set doc [dom parse \
            -useForeignDTD 1 \
            -baseurl $baseURI \
            -externalentitycommand ::tDOM::extRefHandler <root/>]
    set root [$doc documentElement]
    set result [$root @fixed]
    $doc delete
    set result
} {toThis}

test domCmd-6.5 {-useForeignDTD 1 does not overwrite a given external subset} {need_uri} {
    set baseURI file://[file join [pwd] [file dir [info script]] domCmd.test]
    set ::tDOM::useForeignDTD "data/domCmd1.dtd"
    set doc [dom parse \
            -useForeignDTD 1 \
            -baseurl $baseURI \
            -externalentitycommand ::tDOM::extRefHandler {
<!DOCTYPE root SYSTEM "data/domCmd2.dtd">
<root/>}]
    set root [$doc documentElement]
    set result [$root @fixed]
    $doc delete
    set result
} {toThat}

test domCmd-6.6 {-useForeignDTD with nonboolean arg} {need_uri} {
    set result [catch {set doc [dom parse -useForeignDTD foo <root/>]} errMsg]
    lappend result $errMsg
} {1 {expected boolean value but got "foo"}}

test domCmd-7.1 {document with external subset} {need_uri} {
    set baseURI file://[file join [pwd] [file dir [info script]] domCmd.test]
    set doc [dom parse \
            -baseurl $baseURI \
            -externalentitycommand ::tDOM::extRefHandler {
<!DOCTYPE root SYSTEM "data/domCmd2.dtd">
<root/>}]
    set root [$doc documentElement]
    set result [$root @fixed]
    $doc delete
    set result
} {toThat}


set doc [dom parse <root/>]

set xslt1 {
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:param name="param1" select="'param1Default'"/>
    <xsl:param name="param2" select="'param2Default'"/>
    <xsl:param name="param3" select="'param3Default'"/>
    <xsl:template match="/">
        <xsl:value-of select="$param1"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="$param2"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="$param3"/>
        <xsl:text> </xsl:text>
    </xsl:template>
</xsl:stylesheet>}

test domCmd-8.1 {toXSLTcmd} {
    set xslt [dom parse -keepEmpties $xslt1]
    set xsltCmd [$xslt toXSLTcmd]
    
    $xsltCmd -parameters {param2 newValue param3 "this Value"} $doc resultDoc
    set result [$resultDoc asXML -indent none]
    $resultDoc delete
    $xsltCmd -parameters {param1 "that Value"} $doc resultDoc
    append result [$resultDoc asXML -indent none]
    $resultDoc delete
    $xsltCmd -parameters {param3 "another" param1 "and this"} $doc resultDoc
    append result [$resultDoc asXML -indent none]
    $resultDoc delete
    rename $xsltCmd {}
    set result
} {param1Default newValue this Value that Value param2Default param3Default and this param2Default another }

set xslt2 {
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:template match="/">
        <xsl:text>dummy result</xsl:text>
        <xsl:message>This is from xsl:message</xsl:message>
    </xsl:template>
</xsl:stylesheet>}

proc msgCmd1 {msg terminate} {
    global result
    append result "msgCmd1: $msg "
}

proc msgCmd2 {msg terminate} {
    global result
    append result "msgCmd2: $msg"
}

test domCmd-8.2 {toXSLTcmd} {
    set xslt [dom parse -keepEmpties $xslt2]
    set xsltCmd [$xslt toXSLTcmd]

    set result ""
    $xsltCmd -xsltmessagecmd msgCmd1 $doc resultDoc
    $resultDoc delete
    $xsltCmd -xsltmessagecmd msgCmd2 $doc resultDoc
    $resultDoc delete
    rename $xsltCmd {}
    set result
} {msgCmd1: This is from xsl:message msgCmd2: This is from xsl:message}

test domCmd-8.3 {toXSLTcmd} {
    set xslt [dom parse -keepEmpties $xslt1]
    set xsltCmd [$xslt toXSLTcmd]

    set result [catch {$xsltCmd -bogusOption foo $doc resultDoc} errMsg]
    lappend result $errMsg
    lappend result [catch {$xsltCmd $doc resultDoc}]
    lappend result [$resultDoc asXML -indent none]
    $resultDoc delete
    rename $xsltCmd {}
    set result
} {1 {bad option "-bogusOption": must be -parameters, -ignoreUndeclaredParameters, or -xsltmessagecmd} 0 {param1Default param2Default param3Default }}

test domCmd-8.4 {toXSLTcmd} {
    set xslt [dom parse -keepEmpties $xslt1]
    set xsltCmd [$xslt toXSLTcmd]

    set result [catch {$xsltCmd -xsltmessagecmd msgCmd1} errMsg]
    rename $xsltCmd {}
    lappend result $errMsg
} {1 {wrong # args: should be "?-parameters parameterList? ?-ignoreUndeclaredParameters? ?-xsltmessagecmd cmd? <xmlDocObj> ?objVar?"}}

test domCmd-8.5 {toXSLTcmd} {
    set xslt [dom parse -keepEmpties $xslt1]
    set xsltCmd [$xslt toXSLTcmd]

    set result [catch {$xsltCmd $doc resultDoc bogus} errMsg]
    rename $xsltCmd {}
    lappend result $errMsg
} {1 {wrong # args: should be "?-parameters parameterList? ?-ignoreUndeclaredParameters? ?-xsltmessagecmd cmd? <xmlDocObj> ?objVar?"}}

test domCmd-8.6 {toXSLTcmd} {
    set xslt [dom parse -keepEmpties $xslt1]
    set xsltCmd [$xslt toXSLTcmd]

    set result [catch {$xsltCmd -parameters {param1 foo} -parameters {param2 foo} $doc resultDoc} errMsg]
    rename $xsltCmd {}
    lappend result $errMsg
} {1 {only one -parameters option allowed}}

$doc delete

test domCmd-9.1 {asText - syntax check} {
    dom parse <root/> doc
    set result [catch {$doc asText foo}]
    $doc delete
    set result
} {1}

test domCmd-9.2 {asText} {
    dom parse {<root>pcdata <child>foo bar grill</child></root>} doc
    set result [$doc asText]
    $doc delete
    set result
} {pcdata foo bar grill}

test domCmd-9.3 {asText} {
    dom parse {<root>pcdata <![CDATA[<greeting>Hello, world!</greeting>]]>
        more pcdata</root>} doc
    set result [$doc asText]
    $doc delete
    set result
} {pcdata <greeting>Hello, world!</greeting>
        more pcdata}

test domCmd-9.4 {asText} {
    dom parse {<root>pcdata</root>} doc
    $doc documentElement root
    set newCDATAnode \
        [$doc createCDATASection "<greeting>Hello, world!</greeting>"]
    $root appendChild $newCDATAnode
    set result [$doc asText]
    $doc delete
    set result
} {pcdata}

test domCmd-9.5 {asText} {
    dom parse {<root>encoded chars: &gt; &lt; &amp; &quot; &apos;</root>} doc
    set result [$doc asText]
    $doc delete
    set result
} {encoded chars: > < & " '}
# emacs: "

test domCmd-10.1 {normalize} {
    set doc [dom parse <root><child>text</child></root>]
    $doc documentElement root
    set cdataNode [$doc createCDATASection "cdata section text"]
    set child [$root firstChild]
    $child appendChild $cdataNode
    $doc normalize
    set result [llength [$child childNodes]]
    lappend result [[$child firstChild] data]
    $doc delete
    set result
} {2 text}

test domCmd-10.2 {normalize} {
    set doc [dom parse <root><child>text</child></root>]
    $doc documentElement root
    set cdataNode [$doc createCDATASection "cdata section text"]
    set child [$root firstChild]
    $child appendChild $cdataNode
    $doc normalize -forXPath
    set result [llength [$child childNodes]]
    lappend result [[$child firstChild] data]
    $doc delete
    set result
} {1 {textcdata section text}}

test domCmd-10.3 {normalize} {
    set doc [dom parse <root><child/></root>]
    $doc documentElement root
    set cdataNode [$doc createCDATASection "cdata section text"]
    set textNode [$doc createTextNode text]
    set child [$root firstChild]
    $child appendChild $cdataNode
    $child appendChild $textNode
    set result [llength [$child childNodes]]
    $doc normalize -forXPath
    lappend result [llength [$child childNodes]]
    lappend result [[$child firstChild] data]
    $doc delete
    set result
} {2 1 {cdata section texttext}}

test domCmd-10.4 {normalize} {
    set doc [dom parse <root><child/></root>]
    $doc documentElement root
    set cdataNode [$doc createCDATASection "cdata section text"]
    set child [$root firstChild]
    $child appendChild $cdataNode
    $doc normalize
    set result [$cdataNode nodeType]
    $doc normalize -forXPath
    lappend result [$cdataNode nodeType]
    $doc delete
    set result
} {CDATA_SECTION_NODE TEXT_NODE}

test domCmd-10.5 {normalize} {
    set doc [dom parse <root><child/></root>]
    $doc documentElement root
    set textNode [$doc createTextNode ""]
    set child [$root firstChild]
    $child appendChild $textNode
    set result [llength [$child childNodes]]
    $doc normalize
    lappend result [llength [$child childNodes]]
    $doc delete
    set result
} {1 0}

test domCmd-10.6 {normalize} {
    set doc [dom parse <root><child/></root>]
    $doc documentElement root
    set cdataNode [$doc createCDATASection ""]
    set child [$root firstChild]
    $child appendChild $cdataNode
    $doc normalize
    set result [llength [$child childNodes]]
    $doc normalize -forXPath
    lappend result [llength [$child childNodes]]
    $doc delete
    set result
} {1 0}

# cleanup
::tcltest::cleanupTests
return
